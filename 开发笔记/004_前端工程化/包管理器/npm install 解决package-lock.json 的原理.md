在git rebase 或者 git pull 代码时，可能会有package-lock.json 的冲突，我们一般通过npm install，基于package.json 进行重新安装依赖；npm除了安装依赖外，还对package-lock.json中的代码进行了合并；
源代码：[npm/parse-conflict-json](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnpm%2Fparse-conflict-json "https://github.com/npm/parse-conflict-json")
参考博客：[# 如何正确地解决 package-lock.json 合并冲突？](https://juejin.cn/post/7251895470548697143)

合并的原理是：
- 基于 `theirs`，应用 `ours` 的变更
	1. 获取冲突代码，区分 `theirs` 和 `ours` 和 `parent` （正则匹配）
	3. 获取 `parent` 对象到 `ours` 对象的变更
	4. 将变更应用到 `theirs`

diff.json
```json
{
	"ms": {
<<<<<<< HEAD
		"version": "2.1.2"
||||||| merged common ancestors
=======
		"version": "2.1.3",
		"desc": "test"
>>>>>>> feat4
	},
<<<<<<< HEAD
	"c": {
		"x": "bbbb"
	}
||||||| merged common ancestors
	"c": {
		"x": "aaaa"
	}
=======
	"c": "xxxx"
>>>>>>> a
}

```

script.js

```javascript
const parseJSON = require('json-parse-even-better-errors')
const { diff } = require('just-diff')
const { diffApply } = require('just-diff-apply')
const fs = require('fs')
const path = require('path')

const isObj = obj => obj && typeof obj === 'object'

const copyPath = (to, from, path, i) => {
	const p = path[i]
	if (isObj(to[p]) && isObj(from[p]) && Array.isArray(to[p]) === Array.isArray(from[p])) {
		return copyPath(to[p], from[p], path, i + 1)
	}
	to[p] = from[p]
}

const PARENT_RE = /\|{7,}/g // ||||||| 公共的代码
const OURS_RE = /<{7,}/g // <<<<<<< 从这一行往下，是我的代码
const THEIRS_RE = /={7,}/g // ======= 从这一行往下，是对方的代码
const END_RE = />{7,}/g // >>>>>>> 我的代码和对方的代码diff结果的结束行，是一个结束标识

  
const parseConflictJSON = (str, reviver, prefer) => {
	// 解析冲突内容
	const lines = str.split(/[\n\r]+/g)
	const pieces = lines.reduce((acc, line) => {
		if (line.match(PARENT_RE)) {
			acc.state = 'parent'
		} else if (line.match(OURS_RE)) {
			acc.state = 'ours'
		} else if (line.match(THEIRS_RE)) {
			acc.state = 'theirs'
		} else if (line.match(END_RE)) {
			acc.state = 'top'
		} else {
			if (acc.state === 'top' || acc.state === 'ours') {
				acc.ours += line
			}
			if (acc.state === 'top' || acc.state === 'theirs') {
				acc.theirs += line
			}
			if (acc.state === 'top' || acc.state === 'parent') {
				acc.parent += line
			}
		}
		return acc
	}, {
		state: 'top',
		ours: '',
		theirs: '',
		parent: ''
	})
	// 转为对象结构
	const parent = parseJSON(pieces.parent, reviver)
	const ours = parseJSON(pieces.ours, reviver)
	const theirs = parseJSON(pieces.theirs, reviver)
	
	// 获取结果
	return resolve(parent, ours, theirs)
}

const resolve = (parent, ours, theirs) => {
	// 获取 parent 对象到 ours 对象的变更
	const dours = diff(parent, ours)
	// 将变更应用到 theirs
	for (let i = 0; i < dours.length; i++) {
		try {
			diffApply(theirs, [dours[i]])
		} catch (e) {
			// 拷贝 ours 的变更路径至 theirs
			copyPath(theirs, ours, dours[i].path, 0)
		}
	}
	return theirs
}


const diffText = fs.readFileSync(path.join(__dirname, './diff.json'), 'utf-8')
const output = parseConflictJSON(diffText)
fs.writeFileSync(path.join(__dirname, './diff-done.json'), JSON.stringify(output, null, 2), 'utf-8')

console.log('***解析完毕***')

```

diff-done.json
```json

{
	"ms": {
		"version": "2.1.2",
		"desc": "test"
	},
	"c": {
		"x": "bbbb"
	}
}

```
